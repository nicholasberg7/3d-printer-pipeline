#!/usr/bin/env python3
"""
STL Part Splitter - Stage 1: Geometric Splitting
Splits a single STL file into separate parts based on disconnected components
"""

import sys
import os
import json
import numpy as np
from collections import defaultdict
from pathlib import Path

def load_stl_binary(filepath):
    """Load binary STL file"""
    with open(filepath, 'rb') as f:
        # Skip header (80 bytes)
        f.read(80)
        
        # Read number of triangles
        num_triangles = np.frombuffer(f.read(4), dtype=np.uint32)[0]
        
        # Read triangles
        triangles = []
        for _ in range(num_triangles):
            # Normal (3 floats)
            normal = np.frombuffer(f.read(12), dtype=np.float32)
            
            # 3 vertices (9 floats)
            v1 = np.frombuffer(f.read(12), dtype=np.float32)
            v2 = np.frombuffer(f.read(12), dtype=np.float32)
            v3 = np.frombuffer(f.read(12), dtype=np.float32)
            
            # Attribute byte count (2 bytes, ignored)
            f.read(2)
            
            triangles.append({
                'normal': normal,
                'vertices': [v1, v2, v3]
            })
    
    return triangles

def vertex_to_key(vertex, precision=4):
    """Convert vertex to hashable key with rounding"""
    return tuple(np.round(vertex, precision))

def find_connected_components(triangles):
    """Find connected components using vertex connectivity (iterative)"""
    print(f"Analyzing {len(triangles)} triangles...")
    
    # Build vertex adjacency
    vertex_triangles = defaultdict(set)
    
    for tri_idx, tri in enumerate(triangles):
        for vertex in tri['vertices']:
            key = vertex_to_key(vertex)
            vertex_triangles[key].add(tri_idx)
    
    print(f"Found {len(vertex_triangles)} unique vertices")
    
    # Find connected components using iterative BFS
    visited = set()
    components = []
    
    print("Finding connected components...")
    for start_idx in range(len(triangles)):
        if start_idx in visited:
            continue
        
        # BFS from this triangle
        component = set()
        queue = [start_idx]
        visited.add(start_idx)
        component.add(start_idx)
        
        while queue:
            tri_idx = queue.pop(0)
            tri = triangles[tri_idx]
            
            # Find all triangles sharing vertices
            for vertex in tri['vertices']:
                key = vertex_to_key(vertex)
                for neighbor_idx in vertex_triangles[key]:
                    if neighbor_idx not in visited:
                        visited.add(neighbor_idx)
                        component.add(neighbor_idx)
                        queue.append(neighbor_idx)
        
        components.append(component)
        print(f"  Component {len(components)}: {len(component)} triangles")
        
        # Progress update for large models
        if len(visited) % 100000 == 0:
            print(f"    Progress: {len(visited):,}/{len(triangles):,} triangles processed")
    
    return components

def save_stl_binary(filepath, triangles, tri_indices):
    """Save triangles to binary STL file"""
    with open(filepath, 'wb') as f:
        # Write header (80 bytes)
        header = b'STL Part - Generated by split_stl_parts.py' + b' ' * 38
        f.write(header)
        
        # Write number of triangles
        f.write(np.uint32(len(tri_indices)).tobytes())
        
        # Write triangles
        for tri_idx in sorted(tri_indices):
            tri = triangles[tri_idx]
            
            # Write normal
            f.write(tri['normal'].tobytes())
            
            # Write vertices
            for vertex in tri['vertices']:
                f.write(vertex.tobytes())
            
            # Write attribute byte count (0)
            f.write(np.uint16(0).tobytes())

def split_stl(input_file, output_dir):
    """Main splitting function"""
    print(f"\n{'='*60}")
    print(f"STL PART SPLITTER")
    print(f"{'='*60}\n")
    
    # Load STL
    print(f"Loading: {input_file}")
    triangles = load_stl_binary(input_file)
    print(f"Loaded {len(triangles)} triangles\n")
    
    # Find components
    components = find_connected_components(triangles)
    
    print(f"\n{'='*60}")
    print(f"Found {len(components)} separate parts!")
    print(f"{'='*60}\n")
    
    # Create output directory
    os.makedirs(output_dir, exist_ok=True)
    
    # Get base filename
    base_name = Path(input_file).stem
    
    # Save metadata
    metadata = {
        "original_file": input_file,
        "total_triangles": len(triangles),
        "parts": []
    }
    
    # Save each component
    output_files = []
    for idx, component in enumerate(components, 1):
        # Create filename
        output_file = os.path.join(output_dir, f"{base_name}_part_{idx:02d}.stl")
        
        # Save STL
        print(f"Saving part {idx}: {len(component)} triangles → {output_file}")
        save_stl_binary(output_file, triangles, component)
        
        # Add to metadata
        metadata["parts"].append({
            "part_number": idx,
            "filename": os.path.basename(output_file),
            "triangle_count": len(component)
        })
        
        output_files.append(output_file)
    
    # Save metadata
    metadata_file = os.path.join(output_dir, f"{base_name}_parts_metadata.json")
    with open(metadata_file, 'w') as f:
        json.dump(metadata, f, indent=2)
    
    print(f"\nMetadata saved: {metadata_file}")
    
    print(f"\n{'='*60}")
    print(f"✅ SPLITTING COMPLETE!")
    print(f"{'='*60}\n")
    print(f"Parts saved to: {output_dir}/")
    print(f"Total parts: {len(components)}")
    
    return output_files, metadata

def main():
    if len(sys.argv) < 2:
        print("Usage: python split_stl_parts.py <input.stl> [output_dir]")
        print("\nExample:")
        print("  python split_stl_parts.py model.stl parts/")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_dir = sys.argv[2] if len(sys.argv) > 2 else "split_parts"
    
    if not os.path.exists(input_file):
        print(f"Error: File not found: {input_file}")
        sys.exit(1)
    
    try:
        split_stl(input_file, output_dir)
    except Exception as e:
        print(f"\n❌ Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
